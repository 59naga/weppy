<script src="tinybrot.js"></script>
<!-- RIP Benoit Mandelbrot. -->
<script>
/*
  About: This file.
  
  This is a prototype. Hacking together pieces to get it to work as quickly as possible
  (as what I did with ebml the first time). Please don't judge based on this file.
  Well, you're judging anyway. So probably you shouldn't read this unless you somehow 
  manage to plow through the bad code and fix it.
  
  BTW, actually, it would be pretty cool to have a working VP8 video decoder in canvas
  and javascript. That would be freaking awesome. But for certain, I'm not going to and
  if someone else tries, it would be cool if they find out that it's pretty easy because
  I laid the groundwork. But of course, that's not gonna happen, interframe prediction
  is pretty much the biggest thing, isn't it?
  
  Why am I writing this? No idea.
*/

atob("UklGRkYAAABXRUJQVlA4IDoAAABwAgCdASoEAAQAAYcIhYWIhYSIiQIADAzdrBLeABAAAAEAAAEAAPKn5Nn/0v8//Zxn/6H3QAAAAAA=");

function parseRIFF(string){
    var offset = 0;
    var chunks = {};
    while(offset < string.length){
      var id = string.substr(offset, 4);
      var len = parseInt(string.substr(offset+4, 4).split('').map(function(i){
        var unpadded = i.charCodeAt(0).toString(2);
        return (new Array(8 - unpadded.length + 1)).join('0') + unpadded
      }).join(''),2);
      var data = string.substr(offset + 4 + 4, len);
      offset += 4 + 4 + len;
      chunks[id] = chunks[id] || [];
      if(id == 'RIFF'){
        chunks[id].push(parseRIFF(data));
      }else if(id == 'LIST'){
        chunks[id].push(parseRIFF(data));
      }else{
        chunks[id].push(data)
      }
      
    }
    return chunks
  }

  //Converting between a string of 0010101001's and binary back and forth is probably inefficient
  //TODO: get rid of this function
  function toBinStr(bits){
    var data = '';
    var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
    bits = pad + bits;
    for(var i = 0; i < bits.length; i+= 8){
      data += String.fromCharCode(parseInt(bits.substr(i,8),2))
    }
    return data;
  }


    
    function bool_decode(arr){
      var i = 0, value = 0, d = 0, range = 255, bit_count = 0;
      while(++i <= 24) value = (value << 8) | arr[d++];
      var read_bool = function(prob){
        var split = 1 + (((range - 1) * prob) >> 8);
        var SPLIT = split << 8;
        var retval = 0; //0 or 1
        if(value >= SPLIT){
          retval = 1;
          range -= split;
          value -= SPLIT;
        }else{
          retval = 0;
          range = split;
        }
        while(range < 128){
          value <<= 1;
          range <<= 1;
          if(++bit_count == 8){
            bit_count = 0;
            value |= arr[d++];
          }
        }
        console.log(retval);
        return retval;
      }
      return {
        bool: function(prob){
          return read_bool(prob);
        },
        L: function(num_bits){
          var v = 0;
          while(num_bits--) v = (v << 1) + read_bool(128);
          return v
        },
        S: function(num_bits){
          if(!num_bits) return 0;
          var v = 0;
          if(read_bool(128)) v = -1;
          while(--num_bits) v = (v << 1) + read_bool(128);
          return v
        }
      }
    }

function toBinary(string){
  return string.split('').map(function(i){
    var unpadded = i.charCodeAt(0).toString(2);
    return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;
  }).join('')
}
    var graysquare = 'UklGRjYAAABXRUJQVlA4ICoAAAAwAgCdASogACAAC8cIhYWIhYSIv4IAB5FMByADAAABAAABAAD+q8AAAAA=';
    var blacksquare = 'UklGRjgAAABXRUJQVlA4ICwAAAAwAgCdASogACAAC8cIhYWIhYSIv4IAB5DzycAEAAABAAABAAD+5rUAAAAA';
    var circles = 'UklGRkIAAABXRUJQVlA4IDYAAABwAgCdASogACAABQcIhYWIhYSIm4IDO7Rve2Q4AAgAAAUAAAEAAP7fbRm0jZp4TUpRkcAAAA==';
    var circles2 = 'UklGRmIAAABXRUJQVlA4IFYAAACQAwCdASogACAAA8cIhYWIhYSIlIICzgRu1v4CtG26wyquZ2PKMBYAAA4AAAEAAP7K2N2EaD+dq2PkwemM96efe5fgQAAIC2qanJPPO24B+EOakAAA';
    
    webp = atob(circles);
    var VP8 = parseRIFF(webp).RIFF[0].WEBP[0].substr(4);
    
    var Source = VP8.split('').map(function(e){
      return e.charCodeAt(0)
    });
    var c = Source;
    
    tmp = (c[2] << 16) | (c[1] << 8) | c[0];
    key_frame = tmp & 0x1;
    version = (tmp >> 1) & 0x7;
    show_frame = (tmp >> 4) & 0x1;
    first_part_size = (tmp >> 5) & 0x7ffff;
    console.log(key_frame?'interframe':'keyframe', 'v' + version, show_frame?'show':'no-show', 'size', first_part_size);
    if(key_frame == 0){
      if(Source[3] != 0x9d || Source[4] != 0x01 || Source[5] != 42){ //0x2a == 42 and 42 is betterer
        console.log('Unexpected Start Code');
      }
      var c = Source.slice(6);
      tmp = (c[1] << 8) | c[0];
      width = tmp & 0x3fff;
      horizontal_scale = tmp >> 14;
      tmp = (c[3] << 8) | c[2];
      height = tmp & 0x3fff;
      vertical_scale = tmp >> 14;
      console.log('size', width, height);
    }
    
    var decode = bool_decode(Source.slice(6+4));
    
    function mb_lf_adjustments(){
      loop_filter_adj_enable = decode.L(1);
      if(loop_filter_adj_enable){
        console.log('loop filter adj enable');
        console.log('oh noes this is not planned');
        //probably wont happen because it indicates
        //MB-level (assume it means macroblock?) loop filter adjustment based on refrence frame and coding mode
      }
    }
    
    function quant_indices(){
      y_ac_qi = decode.L(7)
      y_dc_delta_present = decode.L(1)
      
      if (y_dc_delta_present) {
        y_dc_delta_magnitude = decode.L(4)
        y_dc_delta_sign = decode.L(1)
      }
      
      y2_dc_delta_present = decode.L(1);
      if (y2_dc_delta_present) {
        y2_dc_delta_magnitude = decode.L(4)
        y2_dc_delta_sign = decode.L(1)
      }
      
      y2_ac_delta_present = decode.L(1);
      if (y2_ac_delta_present) {
        y2_ac_delta_magnitude = decode.L(4)
        y2_ac_delta_sign = decode.L(1)
      }
      
      uv_dc_delta_present = decode.L(1);
      if (uv_dc_delta_present) {
        uv_dc_delta_magnitude = decode.L(4)
        uv_dc_delta_sign = decode.L(1)
      }
      
      uv_ac_delta_present = decode.L(1);
      if (uv_ac_delta_present) {
        uv_ac_delta_magnitude = decode.L(4)
        uv_ac_delta_sign = decode.L(1)
      }
      
    }
    
    function token_prob_update(){
      for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 8; j++) {
          for (var k = 0; k < 3; k++) {
            for (var l = 0; l < 11; l++) {
              coeff_prob_update_flag = decode.L(1)
              if (coeff_prob_update_flag) {
                coeff_prob = decode.L(8)
              }
            }
          }
        }
      }
    }
    
    function mv_prob_update(){
      console.log('this should never happen anyway so why bother implementing it');
    }
    
    if(key_frame == 0){
      color_space = decode.L(1);
      if(color_space != 0) console.log('unsupported non-YCbCr color space');
      clamping_type = decode.L(1);
    }
    segmentation_enabled = decode.L(1);
    if(segmentation_enabled){
      //update segmentation, whatever that means
      console.log('meh im too lazy to implement naw');
    }
    filter_type = decode.L(1);
    loop_filter_level = decode.L(6);
    sharpness_level = decode.L(3);
    mb_lf_adjustments();
    
    log2_nbr_of_dct_partitions = decode.L(2);
    quant_indices();
    if(key_frame == 0){
      refresh_entropy_probs = decode.L(1);
    }else{
      console.log('this should never happen');
    }
    //token_prob_update()
    mb_no_coeff_skip = decode.L(1);
    prob_skip_false = decode.L(8);
    if(key_frame == 1){ //horrible: 0 = true, 1 = false
      console.log('this should never happen');
    }
    
    
    
    mb_skip_coeff = +(mb_no_coeff_skip && decode.L(1));
    
    console.log('mb skip coefficient', mb_skip_coeff);

    is_inter_mb = 0;
    
    function residual_block(){
      var firstCoeff = 0;  //â€¢ firstCoeff is 1 for luma blocks of macroblocks containing Y2 subblock, otherwise 0
      for(var i = firstCoeff; i < 16; i++){
        var token = [];
        tree_read(decode, token, []);
        //if(token == EOB) break;
        //if(token_has_extra_bits){
          //extra_bits = L(n);
          
        //}
        var sign = decode.L(1);
        console.log(token, sign);
      }
    }
    
    if(!mb_skip_coeff){
      for(var i = 0; i < 24; i++){
        //residual_block(); // 16Y 4U 4V
        //console.log(decode.L(1));
      }
    }

    function tree_read(decoder, t, p){
      var i = 0;
      while((i = t[i + decoder.bool(p[i>>1])]) > 0) {};
      return -i;
    }

    var kf_ymode_prob = [145, 156, 163, 128];
    var kf_ymode_tree = [];
    Ymode = tree_read(decode, kf_ymode_tree, kf_ymode_prob);
    
    
</script>
