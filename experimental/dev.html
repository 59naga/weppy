<script src="tinybrot.js"></script>
<script>
function parseRIFF(string){
    var offset = 0;
    var chunks = {};
    while(offset < string.length){
      var id = string.substr(offset, 4);
      var len = parseInt(string.substr(offset+4, 4).split('').map(function(i){
        var unpadded = i.charCodeAt(0).toString(2);
        return (new Array(8 - unpadded.length + 1)).join('0') + unpadded
      }).join(''),2);
      var data = string.substr(offset + 4 + 4, len);
      offset += 4 + 4 + len;
      chunks[id] = chunks[id] || [];
      if(id == 'RIFF'){
        chunks[id].push(parseRIFF(data));
      }else if(id == 'LIST'){
        chunks[id].push(parseRIFF(data));
      }else{
        chunks[id].push(data)
      }
      
    }
    return chunks
  }

  //Converting between a string of 0010101001's and binary back and forth is probably inefficient
  //TODO: get rid of this function
  function toBinStr(bits){
    var data = '';
    var pad = (bits.length % 8) ? (new Array(1 + 8 - (bits.length % 8))).join('0') : '';
    bits = pad + bits;
    for(var i = 0; i < bits.length; i+= 8){
      data += String.fromCharCode(parseInt(bits.substr(i,8),2))
    }
    return data;
  }


    
    function bool_decode(arr){
      var i = 0, value = 0, d = 0, range = 255, bit_count = 0;
      while(++i <= 24) value = (value << 8) | arr[d++];
      var read_bool = function(prob){
        var split = 1 + (((range - 1) * prob) >> 8);
        var SPLIT = split << 8;
        var retval = 0; //0 or 1
        if(value >= SPLIT){
          retval = 1;
          range -= split;
          value -= SPLIT;
        }else{
          retval = 0;
          range = split;
        }
        while(range < 128){
          value <<= 1;
          range <<= 1;
          if(++bit_count == 8){
            bit_count = 0;
            value |= arr[d++];
          }
        }
        return retval;
      }
      return {
        bool: function(prob){
          return read_bool(prob);
        },
        literal: function(num_bits){
          var v = 0;
          while(num_bits--) v = (v << 1) + read_bool(128);
        },
        l1: function(){
          return read_bool(128) //shortcut for L(1) = literal 1 bit
        },
        signed: function(num_bits){
          if(!num_bits) return 0;
          var v = 0;
          if(read_bool(128)) v = -1;
          while(--num_bits) v = (v << 1) + read_bool(128);
          return v
        }
      }
    }

function toBinary(string){
  return string.split('').map(function(i){
    var unpadded = i.charCodeAt(0).toString(2);
    return (new Array(8 - unpadded.length + 1)).join('0') + unpadded;
  }).join('')
}

    var VP8 = parseRIFF(webp).RIFF[0].WEBP[0].substr(4);
    var Source = VP8.split('').map(function(e){
      return e.charCodeAt(0)
    });
    var c = Source;
    
    tmp = (c[2] << 16) | (c[1] << 8) | c[0];
    key_frame = tmp & 0x1;
    version = (tmp >> 1) & 0x7;
    show_frame = (tmp >> 4) & 0x1;
    first_part_size = (tmp >> 5) & 0x7ffff;
    console.log(key_frame, version, show_frame, first_part_size);
    if(key_frame == 0){
      if(Source[3] != 0x9d || Source[4] != 0x01 || Source[5] != 42){ //0x2a == 42 and 42 is betterer
        console.log('Unexpected Start Code');
      }
      var c = Source.slice(6);
      tmp = (c[1] << 8) | c[0];
      width = tmp & 0x3fff;
      horizontal_scale = tmp >> 14;
      tmp = (c[3] << 8) | c[2];
      height = tmp & 0x3fff;
      vertical_scale = tmp >> 14;
      console.log(width, height);
    }
    
    var decode = bool_decode(Source.slice(10));
    
    if(key_frame == 0){
      color_space = decode.l1();
      clamping_type = decode.l1();
    }
    segmentation_enabled = decode.l1();
    if(segmentation_enabled){
      //update segmentation, whatever that means
    }
    filter_type = decode.l1();
    loop_filter_level = decode.literal(6);
    sharpness_level = decode.literal(3);
    //mb_lf_adjustments() whatever that means
    log2_nbr_of_dct_partitions = decode.literal(2);
    //quant_indicies() whatever that means
    if(key_frame == 0){
      refresh_entropy_probs = decode.l1();
    }else{
      console.log('this should never happen');
      refresh_golden_frame = decode.l1();
      refresh_alternate_frame = decode.l1();
      if(!refresh_golden_frame){
        copy_buffer_to_golden = decode.literal(2);
      }
      if(!refresh_alternate_frame){
        copy_buffer_to_alternate = decode.literal(2);
      }
      sign_bias_golden = decode.l1();
      sign_bias_alternate = decode.l1();
      refresh_entropy_probs = decode.l1();
      refresh_last = decode.l1();
    }
    //token_prob_update whatever that is
    mb_no_coeff_skip = decode.l1();
    prob_skip_false = decode.literal(8);
    if(key_frame == 1){ //horrible: 0 = true, 1 = false
      console.log('this should never happen');
      prob_intra = decode.literal(8);
      prob_last = decode.literal(8);
      prob_golden = decode.literal(8);
      intra_16x16_prob_update_flag = decode.l1();
      if(intra_16x16_prob_update_flag){
        for(var i = 0; i < 4; i++){
          intra_16x16_prob = decode.literal(8);
        }
      }
      intra_chroma_prob_update_flag = decode.l1();
      if(intra_chroma_prob_update_flag){
        for(var i = 0; i < 3 /*yes, i love you too*/; i++){
          intra_chroma_prob = decode.literal(8);
        }
      }
      //mv_prob_update, whatever that is
    }
    
</script>
